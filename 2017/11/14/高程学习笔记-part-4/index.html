<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      高程学习笔记 part.4 | HotHunter&#39;s bed 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="hothunter">
    
    

    <meta name="description" content="单体内置对象已经被实例化，不需要显示地实例化。除了Object、Array、String还有Global和Math Gloal:不属于任何其他对象的属性和方法，最终都是它的属性和方法。所有在全局作用域中定义的属性和函数，都是Global的属性。例如isNaN()/isFinite()/parseInt()/parseFloat() URI编码方法：encodeURI()和encodeURIComp">
<meta property="og:type" content="article">
<meta property="og:title" content="高程学习笔记 part.4 | HotHunter&#39;s bed">
<meta property="og:url" content="http://hothunter.com/2017/11/14/高程学习笔记-part-4/index.html">
<meta property="og:site_name" content="HotHunter&#39;s bed">
<meta property="og:description" content="单体内置对象已经被实例化，不需要显示地实例化。除了Object、Array、String还有Global和Math Gloal:不属于任何其他对象的属性和方法，最终都是它的属性和方法。所有在全局作用域中定义的属性和函数，都是Global的属性。例如isNaN()/isFinite()/parseInt()/parseFloat() URI编码方法：encodeURI()和encodeURIComp">
<meta property="og:updated_time" content="2017-11-14T01:20:26.926Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高程学习笔记 part.4 | HotHunter&#39;s bed">
<meta name="twitter:description" content="单体内置对象已经被实例化，不需要显示地实例化。除了Object、Array、String还有Global和Math Gloal:不属于任何其他对象的属性和方法，最终都是它的属性和方法。所有在全局作用域中定义的属性和函数，都是Global的属性。例如isNaN()/isFinite()/parseInt()/parseFloat() URI编码方法：encodeURI()和encodeURIComp">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">HotHunter&#39;s bed</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于我</a></li>
              
                
                <li class="navigation__item"><a href="/lab" title="" class="">实验室</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">高程学习笔记 part.4</h1>

    

    <div class="post-meta">
      <time datetime="2017-11-14" class="post-meta__date date">2017-11-14</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h4 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h4><p>已经被实例化，不需要显示地实例化。除了Object、Array、String<br>还有Global和Math</p>
<p>Gloal:<br>不属于任何其他对象的属性和方法，最终都是它的属性和方法。所有在全局作用域中定义的属性和函数，都是Global的属性。例如isNaN()/isFinite()/parseInt()/parseFloat()</p>
<p>URI编码方法：<br>encodeURI()和encodeURIComponent()可以对URI编码，不能包含空格<br>encodeURI()主要用于整个URI，不对本身属于URI的特殊字符编码，冒号，正斜杠，问号和#<br>encodeURIComponent()用于对URI中的某一段进行编码。对它发现的任何非标准字符进行编码</p>
<pre><code>var uri = &quot;http://www.wrox.com/illegal value.htm#start&quot;;

//&quot;http://www.wrox.com/illegal%20value.htm#start&quot;
alert(encodeURI(uri));

//&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;
alert(encodeURIComponent(uri));
</code></pre><p>与上面两个方法对应的，分别为：<br>decodeURI()/decodeURIComponent()</p>
<pre><code>var uri = &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;;

//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start
alert(decodeURI(uri));

//http://www.wrox.com/illegal value.htm#start
alert(decodeURIComponent(uri));
</code></pre><p>eval()：<br>类似一个完整的ECMAScript解析器，只接受一个参数。要执行的javascript字符串</p>
<pre><code>var (&quot;alert(&apos;hi&apos;)&quot;);
==
alert(&quot;hi&quot;);

var msg = &quot;hello world&quot;;
eval(&quot;alert(msg)&quot;);         //&quot;hello world&quot;

eval(&quot;function sayHi(){alert(&apos;hi&apos;);}&quot;);
sayHi();

eval(&quot;var msg = &apos;hello world&apos;&quot;);
alert(msg);
</code></pre><p>在eval()创建的任何变量或者函数都不会被提升，因为在解析代码的时候，被好汉在一个字符串中；只在eval()执行时被创建。</p>
<p>global对象的属性：<br>undefined / NaN / Infinity / Object / Array / Function / Boolean / String / Number / Date / RegExp / Error / EvalError / RangeError / ReferenceError / SyntaxError / TypeError / URIError<br>明确禁止将undefined/NaN/Infinity赋值</p>
<p>window对象：<br>虽然无法直接访问Global对象，但Web浏览器都将这个全局对象作为window兑现给定而一部分加以实现。</p>
<pre><code>var color = &quot;red&quot;;
function sayColor(){
    alert(window.color);
}
window.sayColor();          //&quot;red&quot;
</code></pre><p>另一种取得Global对象的方法：</p>
<pre><code>var global = function(){
    return this;
}();
</code></pre><p>Math:<br>对象属性：</p>
<ul>
<li>Math.E            //自然对数的底数</li>
<li>Math.LN10         //10的自然对数</li>
<li>Math.LN2          //2的自然对数</li>
<li>Math.LOG2E        //以2为底e的对数</li>
<li>Math.LOG10E       //以10为底e的对数</li>
<li>Math.PI           //π的值</li>
<li>Math.SORT1_2      //1/2的平方根（2的平方根的倒数）</li>
<li>Math.SQRT2        //2的平方根</li>
</ul>
<p><b>虽然讨论这些值的含义和用途超出了本书的范围，但你确实可以随时使用它们</b></p>
<p>min()和max():<br>确定最大值和最小值。可以接收任意多个参数。</p>
<pre><code>var max = Math.max(3, 54, 32, 16);
alert(max);         //54

var min = Math.min(3, 54, 32, 16);
alert(min);         //3

var values = [1, 2, 3, 4, 5, 6, 7, 8];
var max = Math.max.apply(Math, values);
</code></pre><p>把Math对象作为apply()的第一个参数，从而正确设置this。便可以将任何数组作为第二个参数。</p>
<p>舍入方法：<br>Math.ceil():向上舍入，总是将数值向上舍入为最接近的整数<br>Math.floor()：向下舍入，总是将数值向下舍入为最接近的整数<br>Math.round()：四舍五入为最接近的整数。</p>
<pre><code>alert(Math.ceil(25.9));         //26
alert(Math.ceil(25.6));         //26
alert(Math.ceil(25.1));         //26

alert(Math.floor(25.9));        //25
alert(Math.floor(25.6));        //25
alert(Math.floor(25.1));        //25

alert(Math.round(25.9));        //26
alert(Math.round(25.6));        //26
alert(Math.round(25.1));        //25
</code></pre><p>random()：</p>
<p>Math.random()返回大于等于0 小于1的一个随机数。有公式：</p>
<pre><code>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能值);

var num = Math.floor(Math.random() * 10 + 1);    

function selectFrom(lowerValue, upperValue){
    var choices = upperValue - lowerValue + 1;
    return Math.floor(Math.random() * choices + lowerValue);
}

var num = selectFrom(2, 10);
alert(num);         //介于2和10之间（包括2和10）的一个随机数

var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;blace&quot;, &quot;purple&quot;, &quot;brown&quot;];
var color = colors[selectFrom(0, colors.length-1)];
alert(color);           //可能是数组中包含的任何一个字符串
</code></pre><p>其他方法：<br>P136，一些高大上的Math方法</p>
<hr>
<h3 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h3><p>面向对象类语言的共同特点：就是都有类的概念。基于类以创建任意多个具有相同属性和方法的对象。<br>对象：无需属性的集合，起属性可以包含基本值、对象或者函数。<br>每个对象都基于宇哥因引用类型创建，可以是原生类型，也可是自定义类型</p>
<h4 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h4><p>名为person的对象，拥有三个属性（name/age/job），一个方法(sayName):</p>
<pre><code>var person = new Object();
person.name = &quot;hothunter&quot;;
person.age = 29;
person.job = &quot;software engineer&quot;;       //niubi

person.sayName = function(){
    alert(this.name);
}

var person = {
    name : &quot;hothunter&quot;,
    age : 29,
    job : &quot;software engineer&quot;,
    sayName : function(){
        alert(this.name);
    }
};
</code></pre><p>属性类型：<br>包含一个数据值的位置。可以读取和写入。</p>
<ul>
<li>[[Configurable]]:能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li>
<li>[[Enumerable]]:能否通过for-in循环返回属性。</li>
<li>[[Writable]]:能否修改属性的值。</li>
<li>[[Value]]:包含这个属性的数据值</li>
</ul>
<p>修改属性默认特性：Object.defineProperty()。三个参数：属性所在对象、属性名、描述符对象（configurable/enumerable/writable/value）。</p>
<pre><code>var person = {};
Object.defineProperty(person, &quot;name&quot;, {
    writable: false,            //该name属性在此处被设置为只读
    value: &quot;hothunter&quot;
    });

alert(person.name);         //&quot;hothunter&quot;
person.name = &quot;someoneElse&quot;;
alert(person.name);         //&quot;hothunter&quot;

var person = {};
Object.defineProperty(person, &quot;name&quot;, {
    configurable: false,            //在此处被设置为不可删除
    value: &quot;hothunter&quot;
    });

alert(person.name);         //&quot;hothunter&quot;
delete person.name;         
alert(person.name);         //&quot;hothunter&quot;
</code></pre><p>访问器属性：<br>getter/setter函数。读取和写入访问器属性时，分别调用这两个函数。<br>访问器属性特性：</p>
<ul>
<li>[[Configurable]]:表示能否通过delete删除属性从而重新定义属性。</li>
<li>[[Enumerable]]:表示能否通过for-in 循环返回属性。</li>
<li>[[Get]]:在读取属性时调用的函数。默认undefined</li>
<li>[[Set]]:在写入属性时调用的函数。默认undefined</li>
</ul>
<p>仍然需要使用Object.defineProperty()定义</p>
<pre><code>var book = {
    _year = 2015,
    edition: 1
};
Object.defineProperty(book, &quot;year&quot;, {
    get: function(){
        return this._year;
    },
    set: function(newValue){
        if(newValue){
            this._year = newValue;
            this.edition += newValue - 2015;
        }
    }
    });

book.year = 2016;
alert(book.edition);            //2
</code></pre><p>设置一个属性的值会导致其他属性发生变化。</p>
<p>定义多个属性：<br>Object.defineProperties():通过描述符一次定义定义多个属性。两个参数：要添加和修改其属性的对象；第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>
<pre><code>var book = {};
Object.defineProperties(book, {
    _year : {
        writable : true;
        value : 2004
    },
    edition : {
        writable : true,
        value : 1
    }，
    year : function(){
        get: function(){
            return this._year;
        },
        set : function(newValue){
        if(newValue &gt; 2004) {
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
}  
});
</code></pre><p>读取属性的特性：</p>
<p>Object.getOwnPropertyDescriptor()：取得给定属性的描述符。两个参数：所在的对象和要读取其描述符的属性名称。返回一个对象。</p>
<pre><code>var book = {};
Object.defineProperties(book , {
    _year : {
        value : 2004
    },
    edition : {
        value : 1
    },
    year : {
        get : function(){
            return this._year;
        },
        set : function(newValue){
            if (newValue &gt; 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
    });

var descrioptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);
alert(descriptor.value);                //2004
alert(descriptor.configurable);         //false
alert(typeof descriptor.get);           //&quot;undefined&quot;

var descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;);
alert(descriptor.value);                //undefined
alert(descriptor.configurable);         //false
alert(typeof descriptor.get);           //&quot;function&quot;
</code></pre><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>之前创建对象的缺点：使用同一个接口常见很多对系那个，会产生大量的重复代码。</p>
<p>工厂模式：</p>
<p>抽象创建具体对象的过程。</p>
<pre><code>function createPerson(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
    alert(this.name);
};
return o;
}

var person1 = createPerson(&quot;hothunter&quot;, 23, &quot;software enginner&quot;);
var person2 = createPerson(&quot;someoneElse&quot;, 9, &quot;nobody&quot;);
</code></pre><p>缺点：无法解决对象识别的问题（即怎样知道一个对象的类型）</p>
<p>构造函数模式：</p>
<p>以下代码经历四个步骤：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数中的作用域给新对象（因此this指向新对象）；</li>
<li>执行构造函数中的代码（为新对象添加属性）；</li>
<li><p>返回新对象。</p>
<p> function Person(name, age, job){</p>
<pre><code>this.name = name;
this.age = age;
this.job = job;
this.sayName = function(){
    alert(this.name);
};
</code></pre><p> }</p>
<p> var person1 = new Person(“hothunter”, 23, “noob”);<br> var person2 = new Person(“someoneElse”, 9, “motherfucker”);</p>
</li>
</ol>
<p>与之前createPerson()相比，没有显示创建对象；直接将属相和方法赋给了this；没有return。<br>够赞函数始终都应该以一个大写字母开头，非构造函数应该以一个小写字母开头。</p>
<pre><code>alert(person1 instanceof Object);               //true
alert(person1 instanceof Person);               //true
alert(person2 instanceof Object);               //true
alert(person2 instanceof Object);               //true
</code></pre><p>将构造函数当做函数：任何函数，只要通过new操作符来调用，那它就可以作为构造函数；如果不能通过new操作符调用，那和普通函数也没什么区别。</p>
<pre><code>//当做构造函数
var person = new Person(&quot;hothunter&quot;, 23, &quot;software engineer&quot;);
person.sayName();               //&quot;hothutner&quot;

//作为普通函数
Person(&quot;hothunter&quot;, 23, &quot;fucker&quot;);          //添加到window
window.sayName();           //&quot;hothunter&quot;

//在另一个对象的作用域中调用
var o = new Object();
Person.call(o, &quot;Hothunter&quot;, 23, &quot;fucker&quot;);
o.sayName();            //&quot;hothunter&quot;
</code></pre><p>构造函数的问题:<br>每个方法都要在每个实例上重新创建一遍。<br>函数时对象因此每定义一个函数，也就是实例化了一个对象。</p>
<pre><code>function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = new Function(&quot;alert(this.name)&quot;);    
    //与声明函数在逻辑上等价
}

alert(person1.sayName == person2.sayName);          //false
//以此方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例的机制任然相同。因此不同实例上的听命函数时不相等的。

function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = sayName;
}
function sayName(){
    alert(this.name);
}

var person1 = new Person(&quot;hothunter&quot;, 23, &quot;fucker&quot;);
var person2 = new Person(&quot;someoneElse&quot;, 9, &quot;nobody&quot;);
</code></pre><p>以上方法，由于sayName包含的是一个指向函数的指针，因此person1和person2共享了在全局作用域中定义的同一个sayName()函数。<br>但问题是如果需要方法很多，就需要在全局环境创建多个全局函数，繁琐的同时会失去函数的封装性。</p>
<p>原型模式(prototype)：</p>
<p>prototype这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。prototype通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。</p>
<pre><code>function Person(){
}

Person.prototype.name = &quot;hothunter&quot;;
Person.prototype.age = 23;
Person.prototype.job = &quot;fucker&quot;;
Person.prototype.sayName = function(){
    alert(this.name);
};

var person1 = new Person();
person1.sayName();          //&quot;hothunter&quot;

var person2 = new Person();
person2.sayName();          //&quot;hothunter&quot;

alert(person1.sayName == person2.sayName);          //ture
</code></pre><p>理解原型对象：</p>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属相，这个属性指向函数的原型对象。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象。即[[prototype]]。虽然无法直接访问，但各个浏览器都支持一个属性：<strong>proto</strong>。<br>这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</p>
<p>虽然所有实现中都无法访问[[prototype]]，但可以通过isPrototypeOf()方法确定对象之间是存在这种关系。</p>
<pre><code>alert(Person.prototype.isPrototypeOf(person1));     //true
alert(Person.prototype.isPrototypeOf(person2));         //true
</code></pre><p>Object.getPrototypeOf():返回[[prototype]]的值</p>
<pre><code>alert(Object.getPrototypeOf(person1) == Person.prototype);      //true
alert(Object.getPrototypeOf(person2).name);     &quot;hothunter&quot;
</code></pre><p>如果在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。</p>
<pre><code>function Person(){}

Person.prototype.name = &quot;hothunter&quot;;
Person.prototype.age = 23;
Person.prototype.job = &quot;asdf&quot;;
Person.prototype.sayName = function(){
    alert(this.name);
};

var person1 = new Person();
var person2 = new Person();

person1.name = &quot;someoneElse&quot;;
alert(person1.name);        //&quot;someoneElse&quot;
alert(person2.name);        //&quot;hothunter&quot;
</code></pre><p>使用delete可以完全删除实例属性，从而让我们能够重新访问原型中的属性。</p>
<pre><code>function Person(){}

Person.prototype.name = &quot;hothunter&quot;;
Person.prototype.age = 23;
Person.prototype.job = &quot;asdf&quot;;
Person.prototype.sayName = function(){
    alert(this.name);
};

var person1 = new Person();
var person2 = new Person();

person1.name = &quot;someoneElse&quot;;
alert(person1.name);        //&quot;someoneElse&quot;     --  来自实例
alert(person2.name);        //&quot;hothunter&quot;       --  来自原型

delete person1.name;
alert(person1.name);        //&quot;hothunter&quot;       --  来自原型
</code></pre><p>hasOwnProperty():检测一个属性存在于实例中，还是原型中。只在给定属性存在于对象实例中时，才返回true</p>
<pre><code>function Person(){}

Person.prototype.name = &quot;hothunter&quot;;
Person.prototype.age = 23;
Person.prototype.job = &quot;asdf&quot;;
Person.prototype.sayName = function(){
    alert(this.name);
};

var person1 = new Person();
var person2 = new Person();

alert(person1.hasOwnProperty(&quot;name&quot;));      //false

person1.name = &quot;someoneElse&quot;;           
alert(person1.name);        //&quot;someoneElse&quot; --来自实例
alert(person1.hasOwnProperty(&quot;name&quot;));      //true

alert(person2.name);        //&quot;hothunter&quot;   --来自原型
alert(person1.hasOwnProperty(&quot;name&quot;));      //false

delete person1.name;
alert(person1.name);        //&quot;hothunter&quot;   --来自原型
alert(person1.hasOwnProperty(&quot;name&quot;));      //false
</code></pre><p>原型与in操作符</p>
<p>两种使用in：单独使用、在for-i循环中使用。</p>
<pre><code>function Person(){}

Person.prototype.name = &quot;hothunter&quot;;
Person.prototype.age = 23；
Person.prototype.job = &quot;jsfourt&quot;;
Person.sayHello = function(){
    alert(this.name);
};

var person1 = new Person();
var person2 = new Person();

alert(person1.hasOwnProperty(&quot;name&quot;));          //false
alert(&quot;name&quot; in person1);            //true

person1.name = &quot;someoneElse&quot;;
alert(person1.name);            //&quot;someoneElse&quot;--来自实例
alert(perosn1.hasOwnProperty(&quot;name&quot;));          //true
alert(&quot;name&quot; in person1);            //true

alert(person2.name);            //&quot;hothunter&quot;--来自原型
alert(person2.hasOwnProperty(&quot;name&quot;));          //false
alert(&quot;name&quot; in person2);           //true

delete person1.name;
alert(person1.name);            //&quot;hothunter&quot;--来自原型
alert(person1.hasOwnProperty(&quot;name&quot;));          //false
alert(&quot;name&quot; in person1);           //true
</code></pre><p>无论属性存在于实例中还是存在于原型中，调用”name” in person都返回true。<br>同时使用hasOwnProperty()就能确定属性存在于实例中还是原型中。</p>
<pre><code>function hasPrototypeProperty(object, name){
    return !object.hasOwnProperty(name) &amp;&amp; (name in object);
}

function Person(){}

Person.prototype.name = &quot;hothunter&quot;;
Person.prototype.age = 23；
Person.prototype.job = &quot;jsfourt&quot;;
Person.sayHello = function(){
    alert(this.name);
};

var person = new Person();
alert(hasPrototypeProperty(person, &quot;name&quot;))         //true

person.name = &quot;nobody&quot;;
alert(hasPrototypeProperty(person, &quot;name&quot;));        //false
</code></pre><p>使用for-in循环时，返回的是所有嫩巩固通过对象访问、可枚举的（enumerated）属性，包括存在于实例、原型中的属性。屏蔽了原型中不可枚举的属性（[[Enumerable]]被标记为false）的实例也会被循坏。</p>
<pre><code>var o ={
    toString: function(){
        return &quot;My object&quot;;
    }
};
for (var prop in o){
    if (prop == &quot;toString&quot;){
        alert(&quot;Found toString&quot;);
    }
}
</code></pre><p>要取得对象说有可枚举的实例属性，可以使用Object.keys()方法。接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<pre><code>function Person(){}

Person.prototype.name = &quot;hothunter&quot;;
Person.prototype.age = 23；
Person.prototype.job = &quot;jsfourt&quot;;
Person.sayHello = function(){
    alert(this.name);
};

var keys = Object.keys(Person.prototype);
alert(keys);                //&quot;name,age,job,sayName&quot;

var p1 = new Person();
p1.name = &quot;Rob&quot;;
p1.age = 31;
var p1keys = Object.keys(p1);
alert(p1keys);              //&quot;name,age&quot;
</code></pre><p>如果要得到所有实例属性，无论是否可枚举，可以使用Object.getOwnPropertyNames()</p>
<pre><code>var keys = Object.getOwnPropertyNames(Person.prototype);
alert(keys);            //&quot;constructor,name,age,job,sayName&quot;
</code></pre><p>为了减少不必要的输入，也为了从视觉上更好的封装原型功能，更常见的做法是用一个包含所有属性和方法的对象字字面量来重写整个原型对象。</p>
<pre><code>function Person(){}

Person.prototype = {
    name : &quot;hothunter&quot;,
    age : 23,
    job : &quot;student&quot;
    sayName : function(){
        alert(this.name);
    }
};
</code></pre><p>但此时使用constructor已经无法确定对象的类型。本质上重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor(指向Object构造函数)</p>
<pre><code>var friend = new Person();

alert(friend instanceof Object);            //true
alert(friend instanceof Person);            //true
alert(friend.constructor == Person);        //false
alert(friend.constructor == Object);        //true
</code></pre><p>如果constructor的值真的很重要，则可以：</p>
<pre><code>function Person(){}

Person.prototype = {
    constructor : Person,
    name : &quot;hothunter&quot;,
    age : 23,
    job : &quot;student&quot;
    sayName : function(){
        alert(this.name);
    }
};
</code></pre><p>默认情况下constructor属性不可被枚举，可以使用Object.defineProperty();</p>
<pre><code>function Person(){}

Person.prototype = {
    name : &quot;hothunter&quot;,
    age : 23,
    job : &quot;student&quot;
    sayName : function(){
        alert(this.name);
    }
};
//重设构造函数，只适用于ECMAScript5兼容的浏览器
Object.defineProperty(Person.prototype, &quot;constructor&quot;, {
    enumerable : false,
    value : Person
    });
</code></pre><p>原型的动态性：由于在原型中查找值得过程是一次搜索，因此对原型对象所做的任何修改都能够立即从实例反应（即使是先创建了实例后修改原型也如此）</p>
<pre><code>var friend = new Person();

Person.prototype.sayHi = function(){
    alert(&quot;Hi&quot;);
};
friend.sayHi();         //&quot;Hi&quot;
</code></pre><p>可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，情况就会不同。<br>实例中的指针仅指向原型，而不指向构造函数</p>
<pre><code>function Person(){}

var friend = new Person();

Person.prototype = {
    constructor: Person,
    name : &quot;hothunter&quot;,
    age : 23,
    job : &quot;study&quot;,
    sayName : function(){
        alert(this.name);
    }
};

friend.sayName();           //error
</code></pre><p>上面例子首先创建Person实例，然后又重写了原型。在调用friend.sayName()发生错误，因为friend指向的二元性中不包含以改名字命名的属性</p>
<p>所有原生引用类型（Object/Array/String等）都在其构造函数的原型上定义了方法。</p>
<pre><code>alert(typeof Array.prototype.sort);             //&quot;function&quot;
alert(typeof String.prototype.substring);       //&quot;function&quot;
</code></pre><p>通过原生对象的原型，可以取得所有默认方法的引用，而且也可以自定义新方法。可以像修改自定义对象的原型一样修改原对象的原型 ，因此可以随时添加方法。</p>
<pre><code>String.prototype.startsWith = function (text) {
    return this.indexOf(text) == 0;
};

var msg = &quot;Hello world&quot;;
alert(msg.startsWith(&quot;Hello&quot;));     //true
</code></pre><p>当前环境中所有的字符串都可以调用startWith()方法。</p>
<p>原型对象的问题：<br>首先，省略了为构造函数传递初始化参数这一环节，结果所有实例会默认情况下都将取得相同的属性值。虽然会在某种程度上带来一些不方便，但原型模式的最大问题是由其共享的本性所导致的。<br>原型中所有属性被很多实例共享，这种共享对于函数非常合适。通过在实例上添加一个同名属性，可以隐藏原型中对应属性。然而对于包含引用类型值来说问题就突出了</p>
<pre><code>function Person(){}

Person.prototype = {
    constructor : Person,
    name : &quot;hothunter&quot;,
    age : 23
    friends : [&quot;someoneElse&quot;, &quot;nobody&quot;],
    sayName : function(){
        alert(this.name);
    }
};

var person1 = new Person();
var person2 = new Person();

person1.friends.push(&quot;Van&quot;);

alert(person1.friends);         //&quot;someoneElse,nobody,Van&quot;
alert(person2.friends);         //&quot;someoneElse,nobody,Van&quot;
alert(person1.friends === person2.friends);     //true
</code></pre><p>实例一般都要有属于自己的全部属性。这个问题正是很少看到有人单独使用原型模式的原因。</p>
<p>组合使用构造函数模式和原型模式：</p>
<p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。每个实例都会有自己的一份实例属性的副本，同时又共享对方法的引用。同时还支持向构造函数产地参数。</p>
<pre><code>function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    thi.friends = [&quot;fri1&quot;, fri2];
}

Person.prototype = {
    constructor : Person,
    sayName : function(){
        alert(this.name);
    }
}

var person1 = new Person(&quot;hothunter&quot;, 23, &quot;student&quot;);
var person2 = new Person(&quot;someoneElse&quot;, 9, &quot;nobody&quot;);

person1.friends.push(&quot;fri3&quot;);
alert(person1.friends);         //&quot;fri1,fri2,fri3&quot;
alert(person2,firends);         //&quot;fri1,fri2&quot;
alert(person1,firends === person2.friends);     //false
alert(person1.sayName === person2.sayName);     //true
</code></pre><p>这种够赞函数与原型混成的模式，是目前默认的定义引用类型的模式。</p>
<p>动态原型模式：</p>
<p>把所有信息都封装在构造函数中，而通过在构造函数中初始化原型，又保持了同事使用构造函数和原型的有点。<br>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
<pre><code>function Person(name, age, job){
    //属性
    this.name = name;
    this.age = age;
    this.job = job;
    //方法
    if (typeof this.sayName != &quot;function&quot;){
        Person.prototype.sayName = function(){
            alert(this.name);
        };
    }
}

var friend = new Person(&quot;hothunter&quot;, 23, &quot;study&quot;);
friend.sayName();
</code></pre><p>这段代码只会在初次调用构造函数式才会执行。伺候原型已经完成初始化，不需要再做什么修改。但这里对原型所做的修改，能够立即在所有实例中得到反映。if语句煎炒的可以是初始化之后应该存在的任何属性或方法–不必用一大堆if语句检查每个属性和每个方法；只需要一个即可。对于采用这种模式创建的对象，还可以使用instanceof判断。</p>
<p>计生构造函数模式：<br>寄生（parasitic）构造模式的基本思想是创建一个函数，作用仅仅是封装创建对象的代码，然后再返回新创建的对象。</p>
<pre><code>function Person(){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o;
}

var friend = new Person(&quot;hothunter&quot;, 23, &quot;study&quot;);
friend.sayName();       //&quot;hothunter&quot;
</code></pre><p>这个模式可以在特殊的额情况下用来为对象创建构造函数。假设常见一个具有额外方法的特殊数组。由于不能直接修改Array，因此：</p>
<pre><code>function SpecialArray(){
    //创建数组
    var values = new Array();
    //添加值
    value.push.apply(values, arguments);
    //添加方法
    value.toPipedString = function(){
        return this.join(&quot;|&quot;);
    };
    //返回数组
    return values;
}

var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);
alert(colors.toPipedString());      //&quot;red|blue|green&quot;
</code></pre><p>需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说构造函数返回的对象与在构造函数外部创建的对象没有不同。不能依赖instanceof操作符来确定对象类型。</p>
<p>稳妥构造函数模式：</p>
<p>稳妥对象（durable objects）：指没有公共属性，而且其方法也不引用this对象。同时也不使用new</p>
<pre><code>function Person(name, age, job){
    //创建要返回的对象
    var o = new Object();
    //可以再这里定义私有变量和函数
    //添加方法
    o.sayName = function(){
        alert(name);
    };
    //返回对象
    return o;
}

var friend = new Person(&quot;hothunter&quot;, 23, &quot;study&quot;);
friend.sayName();               //&quot;hothunter&quot;
</code></pre><p>除了调用sayName方法，么有别的方式可以访问数据成员。即使有其他代码会给这个而对象添加方法或者数据成员，蛋液不可能有别的而方法啊访问传入到构造函数中的原始数据</p>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <!-- <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span> -->
    <span class="footer__copyright">呦~❤</span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    
    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
