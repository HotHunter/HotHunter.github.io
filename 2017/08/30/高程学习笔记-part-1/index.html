<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      高程学习笔记 part.1 | HotHunter&#39;s bed 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="hothunter">
    
    

    <meta name="description" content="here we go #JS高程学习笔记  ###第一章 javascript简介     P1一个完整的javascript实现由三部分组成：  核心（ECMAscript） 文档对象模型（DOM） 浏览器对象模型（BOM）  ECMAscript由ECMA-262定义的ECMAscript与web浏览器没有依赖关系。ECMA-262规定了：语法/类型/语句/关键字/保留字/操作符/对象ECMA">
<meta property="og:type" content="article">
<meta property="og:title" content="高程学习笔记 part.1 | HotHunter&#39;s bed">
<meta property="og:url" content="http://hothunter.com/2017/08/30/高程学习笔记-part-1/index.html">
<meta property="og:site_name" content="HotHunter&#39;s bed">
<meta property="og:description" content="here we go #JS高程学习笔记  ###第一章 javascript简介     P1一个完整的javascript实现由三部分组成：  核心（ECMAscript） 文档对象模型（DOM） 浏览器对象模型（BOM）  ECMAscript由ECMA-262定义的ECMAscript与web浏览器没有依赖关系。ECMA-262规定了：语法/类型/语句/关键字/保留字/操作符/对象ECMA">
<meta property="og:updated_time" content="2017-10-10T07:15:16.971Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高程学习笔记 part.1 | HotHunter&#39;s bed">
<meta name="twitter:description" content="here we go #JS高程学习笔记  ###第一章 javascript简介     P1一个完整的javascript实现由三部分组成：  核心（ECMAscript） 文档对象模型（DOM） 浏览器对象模型（BOM）  ECMAscript由ECMA-262定义的ECMAscript与web浏览器没有依赖关系。ECMA-262规定了：语法/类型/语句/关键字/保留字/操作符/对象ECMA">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">HotHunter&#39;s bed</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于我</a></li>
              
                
                <li class="navigation__item"><a href="/lab" title="" class="">实验室</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">高程学习笔记 part.1</h1>

    

    <div class="post-meta">
      <time datetime="2017-08-30" class="post-meta__date date">2017-08-30</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <p>here we go</p>
<p>#JS高程学习笔记</p>
<hr>
<p>###第一章 javascript简介     P1<br>一个完整的javascript实现由三部分组成：</p>
<ul>
<li>核心（ECMAscript）</li>
<li>文档对象模型（DOM）</li>
<li>浏览器对象模型（BOM）</li>
</ul>
<h4 id="ECMAscript"><a href="#ECMAscript" class="headerlink" title="ECMAscript"></a>ECMAscript</h4><p>由ECMA-262定义的ECMAscript与web浏览器没有依赖关系。<br>ECMA-262规定了：语法/类型/语句/关键字/保留字/操作符/对象<br>ECMAScript就是对实现该标准的各个方面内容的语言的描述。</p>
<p>！：ECMAScript的版本/ECMAScript的兼容问题/web浏览器对ECMAScript的支持</p>
<h4 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM-文档对象模型"></a>DOM-文档对象模型</h4><p>针对XML但经过扩展用于HTML的应用程序编程接口。将整个页面映射为一个多层次节点结构<br>DOM1级：</p>
<ul>
<li>DOM-core：规定如何映射基于XML的文档结构，便于简化对文档中任意部分的访问和操作。</li>
<li>DOM HTML：在DOM核心模块上加以扩展，添加针对HTML的对象和方法。<br>DOM2级：<br>引入新接口：DOM视图。DOM事件。DOM样式。DOM遍历和范围<br>DOM3级：<br>进一步扩展：DOM加载和保存。DOM验证</li>
</ul>
<h4 id="BOM-浏览器对象模型"><a href="#BOM-浏览器对象模型" class="headerlink" title="BOM-浏览器对象模型"></a>BOM-浏览器对象模型</h4><p>浏览器窗口对象模型，用于控制页面以外的部分。在hTML5中加入正式规范，习惯吧所有针对浏览器的javascript扩展算作BOM的一部分。</p>
<hr>
<h3 id="第二章-在HTML中使用JAvaScript-P10"><a href="#第二章-在HTML中使用JAvaScript-P10" class="headerlink" title="第二章 在HTML中使用JAvaScript      P10"></a>第二章 在HTML中使用JAvaScript      P10</h3><h4 id="HTML中插入js"><a href="#HTML中插入js" class="headerlink" title="HTML中插入js"></a>HTML中插入js</h4><p>属性：</p>
<ul>
<li>async：立即加载</li>
<li>charset：通过src制定的代码的字符集（被忽略）</li>
<li>defer：延迟加载</li>
<li>language：生命编写的脚本语言（已废弃）</li>
<li>src：包含要执行代码的外部文件</li>
<li><p>type：language的替代属性，表示编写代码使用的脚本语言内容类型</p>
  <script type="text/javascript">
      function sayScript(){
          alert("<\/script>");
          //alert("</script>");
      }
  

  <script type="text/javascript" src="javascript.js"></script>

</li>
</ul>
<p>!：带有src属性的script标签中不应该有额外的js代码，会被忽略</p>
<p>src可以加载外部域的js文件（同img）</p>
<p>无defer和async属性时按顺序加载js文件</p>
<p>按照传统，所有<script></script>应该放在<head></head>中，但为了页面相应速度，均将与页面样式无关的js放在<body></body>后加载。</p>
<p>!：异步脚本一定会在页面的load时间前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。</p>
<p>引用外部js文件好处：可维护性，克缓存，适应未来。</p>
<p>文档模式：混杂模式/标准模式</p>
<h3 id="第三章-基本概念-P19"><a href="#第三章-基本概念-P19" class="headerlink" title="第三章 基本概念        P19"></a>第三章 基本概念        P19</h3><p>ECMAscript中的变量/函数名/操作符都区分大小写。</p>
<p>标识符的命名规则：第一个字符为字母/_/$   驼峰/下划线</p>
<p>“严格模式”：头部添加编译指示’use strict’</p>
<p>ECMAScript定义变量为松散型，变量作为占位符用于存储任何值。省略var操作符，变量为全局变量。</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h5><pre><code>var mes;
alert(mes == undefined); //true

var mes = undefined;
alert(mes == undefined); //true

var mes;
//var age;
alert(mes); //&quot;undefined&quot;
alert(age); //错误
alert(typeof mes);  //&quot;undefined&quot;
alert(typeof age);  //&quot;undefined&quot;
</code></pre><h5 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h5><p>Null类型只有一个值，为null。null值表示一个空对象指针</p>
<pre><code>nar car = null;
alert(typeof car);  //&quot;object&quot;

//可作为判断一个初始化的对象是否产生值的变化
if(car != null){
    //do something
}

alert(null == undefined); //true
</code></pre><p>undefined派生自null</p>
<h5 id="bolean"><a href="#bolean" class="headerlink" title="bolean"></a>bolean</h5><pre><code>var mes = &quot;hello world&quot;;
if(mes){
    alert(&quot;true&quot;);
}
</code></pre><h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><p>同时表示整数和浮点数</p>
<pre><code>var intNum = 5; //整数
var ocalNum1 = 070; //八进制的56
var ocalNum2 = 079; //无效的八进制数值-解析为79
var ocalNum3 = 08;  //无效的八进制数值-解析为8
var hexNum1 = 0xA;  //十六进制的10
var hexNum2 = 0x1f; //十六进制的31
</code></pre><p>在计算时，所有八进制和十六进制表的的数值都将转换成十进制数。</p>
<pre><code>var floatNum1 = 1.1;
var floatNum2 = 0.1;
var floatNum3 = .1;         //有效，但不推荐
var floatNum4 = 1.;         //无效，解析为1
var floatNum5 = 10.0;       //证书，解析为10
var floatNum6 = 3.125e7     //对于极大或极小的数值，用e表示
</code></pre><p>！：0.1+0.2 != 0.3  实际为0.3000000000000000004。这是使用基于IEEE数值的浮点计算的通病。</p>
<pre><code>if (a + b == 0.3){      //不要做这样的测试
    alert(&quot;you get 0.3&quot;)
}
</code></pre><p>NaN：非数值（Not a Number）审核书除以非数值返回NaN。任何设计NaN的操作（NaN/10）都会返回NaN。NaN与任何值都不相等，包括NaN本身</p>
<pre><code>alert(NaN == NaN);      //false
alert(isNaN(NaN));      //true
alert(isNaN(10));       //false(10为整数)
alert(isNaN(&quot;10&quot;));     //false(可以被转换为10)
alert(isNaN(&quot;blue&quot;));   //true(不能被转换为数值)
alert(isNaN(true));     //false(可被转换为1)
</code></pre><p>Nubmer的转换规则：</p>
<ul>
<li>boolean，true/false分别转换为1/0</li>
<li>数字值，只是简单的传入和返回</li>
<li>null，返回0</li>
<li>undefined，返回NaN</li>
<li>字符串<ul>
<li>只包含数字，转换为十进制</li>
<li>包含浮点数，转会为对应的浮点数</li>
<li>包含有效十六进制，转为对应大小十进制</li>
<li>为空，0</li>
<li>包含除以上格式外的字符，NaN</li>
</ul>
</li>
<li><p>对象，则调用valueOf()，在依照上面的规则转换</p>
<p>  var num1 = Number(“hello”);     //NaN<br>  var num2 = Number(“”);          //0<br>  var num3 = Number(“000001”);    //1<br>  var num4 = Number(true);        //1</p>
</li>
</ul>
<p>parseInt():拥有第二参数：进制数(建议使用)</p>
<pre><code>var num = parseInt(&quot;1234blue&quot;);     //1234
var num = parseInt(&quot;&quot;);             //NaN
var num = parseInt(&quot;0xA&quot;);          //10
var num = parseInt(22.5);           //22
var num = parseInt(&quot;070&quot;);          //56
var num = parseInt(&quot;70&quot;);           //70
var num = parseInt(&quot;0xf&quot;);          //15
var num = parseInt(&quot;0xAF&quot; , 16);    //175
var num = parseInt(&quot;AF&quot; , 16);      //175
var num = parseInt(&quot;AF&quot;);           //NaN
</code></pre><p>parseFloat()：只有第一个小数点有效；忽略前导零，十六进制始终转换成0。只解析十进制数</p>
<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><pre><code>var firstName = &quot;hothunter&quot;;
var lastName = &apos;hothunter&apos;;
</code></pre><p>转义序列：</p>
<ul>
<li>\n        换行</li>
<li>\t        指标</li>
<li>\b        退格</li>
<li>\r        回车</li>
<li>\f        进纸</li>
<li>\\       斜杠</li>
<li>\’        单引号</li>
<li>\”        双引号</li>
<li>\xnn      以十六进制nn表示一个字符  \x41表示”A”</li>
<li>\unnnn    以十六进制nnnn表示一个Unicode字符（n为0~F）\u03a3表示（求和符号sigma，我不会打。。）</li>
</ul>
<p>例子：</p>
<pre><code>var text = &quot;This is the letter sigma: \u03a3.&quot;;
alert(text.length);     //28

var lang = &quot;Java&quot;;
lang = lang + &quot;Script&quot;;

var age = 11;
var ageAsString = age.toString();       //&quot;11&quot;
var found = true;
var foundAsString = found.toString();   //&quot;true&quot;
</code></pre><p>null和undefined 无toString()方法。toString()有一个基数参：</p>
<pre><code>var num = 10;
alert(num.toString());      //&quot;10&quot;
alert(num.toString(2));     //&quot;1010&quot;
alert(num.toString(8));     //&quot;12&quot;
alert(num.toString(10));    //&quot;10&quot;
alert(num.toString(16));    //&quot;a&quot;
</code></pre><p>String():将任何类型的值转换为字符串：</p>
<pre><code>var value1 = 10;
var value2 = true;
var value3 = null;
var value4;
alert(String(value1));      //&quot;10&quot;
alert(String(value2));      //&quot;true&quot;
alert(String(value3));      //&quot;null&quot;
alert(String(value4));      //&quot;undefined&quot;
</code></pre><p>可以使用“+”，将某个值与一个””字符串相加从而转化为字符串。</p>
<h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h5><p>一组数据和功能的集合。对象可以通过执行new后跟要创建的对象类型的名称创建。创建Object类型的实例并为其添加添加属性/方法以创建自定义对象。</p>
<pre><code>var obj = new Object();
</code></pre><p>Object类型是所有它的实例的基础，Object所具有的任何属性和方法同样存在于更具体的对象中：</p>
<ul>
<li>constructor:构造函数，保存用于创建当前对象的函数。上面的Object()</li>
<li>hasOwnProperty(propertyName):检查给定的propertyName在当前对象实例中是否存在。</li>
<li>isPrototypeOf(object):检查传入的对象是否是当前对象的原型。</li>
<li>propertyIsEnumerable(propertyName):检查给定的属性是否能够使用for-in语句来枚举。</li>
<li>toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。【这个啥意思没看懂】</li>
<li>toString():返回字符串</li>
<li>vlaueOf():返回字符串/数值/布尔值。通常与toString()返回值相同。</li>
</ul>
<h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><p>++/– ：</p>
<pre><code>var age = 29;
++age;      //age = age + 1;
</code></pre><p>在执行递增和递减时，变量的值都是在语句被求值以前改变的</p>
<pre><code>var age = 29;
var anotherAge = --age + 2;
alert(age);         //28
alert(anotherAge);  //30
</code></pre><p>由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。</p>
<pre><code>var num1 = 2;
var num2 = 20;
var num3 = --num1 + num2;       //21
var num4 = num1 + num2;         //21
</code></pre><p>！：后置递增递减实在包含它们的语句被求值之后才执行。</p>
<pre><code>var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2;       //22
var num4 = num1 + num2          //21
</code></pre><p>操作符转换规则：”2” -&gt; 2 / “ff” -&gt; NaN    /   false -&gt; 0  /   true -&gt; 1   /Object() -&gt; valueOf()</p>
<pre><code>var s1 = &quot;2&quot;;
var s2 = &quot;a&quot;;
var b = false;
var f = 1.1;
var obj = {valueOf: function(){return -1}};
//
s1++;           //3
s2++;           //NaN
b++;            //1
f--;            //0.10000000000000009(浮点舍入错误导致)
obj--;          //-2   
</code></pre><p>位操作符，&amp; | ~<br>以0填充移动后的空位<br>左移  &lt;&lt;    </p>
<pre><code>var oldValue = 2;                   //二进制的10
var newValue = oldValue &lt;&lt; 5;       //等于二进制的1000000，十进制的64
</code></pre><p>有符号的右移 &gt;&gt;</p>
<pre><code>var oldValue = 64;              //二进制的1000000
var newValue = oldVlaue &gt;&gt; 5;   //二进制的10，2
</code></pre><p>无符号的右移  &gt;&gt;&gt;     将负数的二进制码转换成正数的二进制码；负数无符号右移后结果非常大。</p>
<pre><code>var oldValue = -64;             //等于二进制的 11111111111111111111111111000000
var newValue = oldValue &gt;&gt;&gt; 5   //等于十进制的134217726 
</code></pre><p>布尔操作符：与或非</p>
<p>逻辑非（!）：将被操作数转换成布尔值之后求反</p>
<pre><code>alert(!false);      // true
alert(!&quot;blue&quot;);     // false
alert(!0);          // true
alert(!NaN);        // true
alert(!&quot;&quot;);         // true
alert(!1234);       // false
</code></pre><p>逻辑与（&amp;&amp;）：可以用于任何类型的操作数</p>
<pre><code>var found = true;
var result = (found &amp;&amp; someUndefinedVariable);      //someUndefinedVariable未被定义，这里会出错
</code></pre><p>逻辑或（||）</p>
<pre><code>var myObject = preferredObject || backupObject;     //赋值方式
</code></pre><p>乘性操作符</p>
<pre><code>var result = 34 * 56;
var result = 66 / 11;
var result = 26 % 5;
</code></pre><p>加性操作符</p>
<pre><code>//加法
var result1 = 5 + 5;
alert(result1);         //10
var result2 = 5 + &quot;5&quot;;
alert(result2);         //&quot;55&quot;

var num1 = 5;
var num2 = 10;
var message = &quot;The sum of 5 and 10 is &quot; + (num1 + num2);
alert(message);                 //&quot;The sume of 5and 10 is 15&quot;

//减法
var result1 = 5 - true;     //4  true -&gt; 1
var result2 = NaN - 1;      //NaN
var result3 = 5 - 3;        //2
var result4 = 5 - &quot;&quot;;       //5  &quot;&quot; -&gt; 0
var result5 = 5 - &quot;2&quot;;      //3
var result6 = 5 - null      //5
</code></pre><p>注意以上加性乘性操作符对于+—0以及+—Infinity等特殊情况的规则。</p>
<p>关系操作符：</p>
<pre><code>var result1 = 5 &gt; 3;     //true
var result2 = 5 &lt; 3;     //false
</code></pre><p>在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。比较后再返回一个布尔值。<br>大写字母字符编码全部小于小写字母字符编码。</p>
<pre><code>var result = &quot;Brick&quot; &lt; &quot;alphabet&quot;;      //true
var result = &quot;23&quot; &lt; &quot;3&quot;;                //true &quot;2&quot;的字符编码50，&quot;3&quot;51
var result = &quot;23&quot; &lt; 3;                  //false     
var result = &quot;a&quot;  &lt; 3;                  //false a-&gt;NaN
var result1 = NaN &lt; 3;                  //false
var result2 = NaN &gt;= 3;                 //false
</code></pre><p>相等操作符</p>
<p>相等和不相等（== / !=）：强转型后比较相等性<br>全等和不全等（=== / !===）：不转型直接比较</p>
<pre><code>var result1 = (&quot;55&quot; == 55);         //true
var result2 = (&quot;55&quot; === 55);        //false
var result3 = (&quot;55&quot; != 55);         //false
var result4 = (&quot;55&quot; !== 55);        //true
null == undefined                   //true
null === undefined                  //false
</code></pre><p>条件操作符</p>
<pre><code>variable = boolean_expression ? true_value : false_value;
var max = (num1 &gt; num2) ? num1 : num2;
</code></pre><p>赋值操作符</p>
<pre><code>var num = 10;
num = num + 10;
num += 10;
</code></pre><ul>
<li>*=</li>
<li>/=</li>
<li>%=    模赋值</li>
<li>+=</li>
<li>-=</li>
<li>&lt;&lt;=   左移赋值</li>
<li><blockquote>
<blockquote>
<p>=   右移赋值</p>
</blockquote>
</blockquote>
</li>
</ul>
<p>逗号操作符<br>逗号用于赋值时，总会返回表达式中最后一项</p>
<pre><code>var num1 = 1,num2 = 2, num3 = 3;
var num = (5, 1, 4 ,8 ,0);  //num的值为0
</code></pre><h5 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h5><h6 id="if"><a href="#if" class="headerlink" title="if"></a>if</h6><pre><code>if(i &gt; 25){
    alert(&quot;Greater then 25.&quot;);
}else if(i &lt; 0){
    alert(&quot;Less than 0.&quot;);
}else {
    alert(&quot;Between 0 and 25, inclusive.&quot;)
}
</code></pre><h6 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h6><pre><code>do {
    statement
} while (expression);
//
var i = 0;
do {
    i += 2;
} while (i &lt; 10);
alert(i);
</code></pre><h6 id="while"><a href="#while" class="headerlink" title="while"></a>while</h6><pre><code>var i = 0;
while (i &lt; 10){
    i += 2;
}
</code></pre><h6 id="for"><a href="#for" class="headerlink" title="for"></a>for</h6><p>前测试循环语句，执行循环之前初始化变量和定义循环后要执行的代码的能力。</p>
<pre><code>var count = 10;
//var i;
for(i = 0;i &lt; count;i++){
    alert(i);
}

for(;;){        //无限循环
    doSomething();
}
</code></pre><h6 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h6><p>更精准的迭代语句，可以用来枚举对象的属性。循环输出的顺序不可预测</p>
<pre><code>for(var propName in window){
    document.write(propName);
}
</code></pre><h6 id="label"><a href="#label" class="headerlink" title="label"></a>label</h6><p>添加标签以便将来使用。</p>
<pre><code>start: for(var i = 0;i &lt; count; i++){
    alert(i);
}
</code></pre><h6 id="break-continue"><a href="#break-continue" class="headerlink" title="break / continue"></a>break / continue</h6><p>break终止循环体，退出循环，强制继续执行循环后面的代码。<br>continue停止本次循环，但不会跳出循环体。</p>
<pre><code>var num = 0;
for (var i = 1; i &lt; 10; i++){
    if (i % 5 == 0){
        break;
    }
    num++;
}
alert(num);             //4

var num = 0;
for (var i = 1; i &lt; 10; i++){
    if (i % 5 == 0){
        continue;
    }
    num++;
}
alert(num);             //8
</code></pre><p>break/continue 配合label 跳出到指定位置。</p>
<pre><code>var num = 0;
outermost:
for(var i = 0; i &lt; 10; i++){
    for(var j=0; j &lt; 10; j++){
        if ( i == 5 &amp;&amp; j == 5){
            break outermost;
        }
    }
}
alert(num);                             //55

var num = 0;
outermost:
for(var i = 0; i &lt; 10; i++){
    for(var j=0; j &lt; 10; j++){
        if ( i == 5 &amp;&amp; j == 5){
            continue outermost;
        }
    }
}
alert(num);                             //95
</code></pre><h6 id="with"><a href="#with" class="headerlink" title="with"></a>with</h6><p>将代码的作用域设置到一个特定的对象中</p>
<pre><code>var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;
</code></pre><p>可以使用with语句，改写成</p>
<pre><code>var qs = search.substring(1);
var hostName = hostname;
var url = href;
</code></pre><p>改写后意味着在with语句的代码块中，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location兑现各种是否有同名的属性，如果发现了同名，则以location对象属性的值作为变量的值。<br>严格模式不允许使用with。</p>
<h6 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h6><pre><code>switch (i){
    case 15:        //合并两种情况
    case 25:
        alert(&quot;25&amp;15&quot;);
        break;
    case 35:
        alert(&quot;35&quot;);
        break;
    case 45:
        alert(&quot;45&quot;);
        break;
    default:
        alert(&quot;Other&quot;);
}
</code></pre><p>除此以外的case条件还可以有：</p>
<pre><code>case &quot;Hello&quot; + &quot; world&quot;:
case &quot;goodbye&quot;:
case num &lt; 0:
case num &gt; 0 &amp;&amp; num &lt;=10:
</code></pre><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><pre><code>function functionName(arg0,arg1,...,argN) {
    statements
}
function sum(num1, num2){
    return num1 + num2;
    alert(&quot;这句永远不会被执行&quot;);
}
</code></pre><p>不在意传入参数类型以及个数，参数存储在arguments对象中（类似数组）<br>参数数量为arguments.length，参数i为arguments[i]</p>
<pre><code>function howMaryArgs(){
    alert(arguments.length);
}
howMaryArgs(&quot;String&quot;, 45);      //2
howMaryArgs();                  //0
howMaryArgs(23);                //1

function doAdd(num1, num2){
    if(arguments.length == 1){
        alert(num1 + 10);
    }else if(argument.length == 2){
        alert(arguments[0] + num2);
    }
}
</code></pre><p>arguments的值永远与对应命名参数的值保持同步。</p>
<pre><code>function doAdd(num1, num2){
    arguments[1] = 10;
    alert(arguments[0] + num2);
}
</code></pre><p>没有传递值的参数自动被赋予undefined。<br>ECMAScript的幻术不能像传统意义上实现重载。当定义两个名字相同的函数，改名字只属于后定义的函数</p>
<pre><code>function addSomeNumber(num){
    return num + 100;
}
function addSomeNumber(num){
    return num + 200;
}
var result addSomeNumber(100);              //300
</code></pre>
  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <!-- <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span> -->
    <span class="footer__copyright">呦~❤</span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    
    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
