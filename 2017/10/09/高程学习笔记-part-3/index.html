<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      高程学习笔记 part.3 | HotHunter&#39;s bed 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="hothunter">
    
    

    <meta name="description" content="Function 类型函数即为对象，每个函数都是Function类型的实例，都与其他引用类型一样具有属性和方法。函数名实际上也即是一个纸箱函数对象的指针，不会与某个函数绑定。 function sum(num1, num2){     return num1 + num2; } === var sum = function(num1, num2){     return num1 + num2;">
<meta property="og:type" content="article">
<meta property="og:title" content="高程学习笔记 part.3 | HotHunter&#39;s bed">
<meta property="og:url" content="http://hothunter.com/2017/10/09/高程学习笔记-part-3/index.html">
<meta property="og:site_name" content="HotHunter&#39;s bed">
<meta property="og:description" content="Function 类型函数即为对象，每个函数都是Function类型的实例，都与其他引用类型一样具有属性和方法。函数名实际上也即是一个纸箱函数对象的指针，不会与某个函数绑定。 function sum(num1, num2){     return num1 + num2; } === var sum = function(num1, num2){     return num1 + num2;">
<meta property="og:updated_time" content="2017-10-10T07:01:29.050Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高程学习笔记 part.3 | HotHunter&#39;s bed">
<meta name="twitter:description" content="Function 类型函数即为对象，每个函数都是Function类型的实例，都与其他引用类型一样具有属性和方法。函数名实际上也即是一个纸箱函数对象的指针，不会与某个函数绑定。 function sum(num1, num2){     return num1 + num2; } === var sum = function(num1, num2){     return num1 + num2;">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">HotHunter&#39;s bed</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于我</a></li>
              
                
                <li class="navigation__item"><a href="/lab" title="" class="">实验室</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">高程学习笔记 part.3</h1>

    

    <div class="post-meta">
      <time datetime="2017-10-09" class="post-meta__date date">2017-10-09</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h4 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h4><p>函数即为对象，每个函数都是Function类型的实例，都与其他引用类型一样具有属性和方法。函数名实际上也即是一个纸箱函数对象的指针，不会与某个函数绑定。</p>
<pre><code>function sum(num1, num2){
    return num1 + num2;
}
===
var sum = function(num1, num2){
    return num1 + num2;
};

var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1+num2&quot;); //不推荐
</code></pre><p>函数名仅仅是纸箱函数体的指针，一个函数可能有多个名字</p>
<pre><code>function sum(num1 , num2){
    return num1 + num2;
}
alert(sum(10, 10));         //20

var anotherSum = sum;
alert(anotherSum(10, 10));  //20

sum = null;
alert(anotherSum(10, 10));  //20
</code></pre><p>没有重载：<br>ECMAScript中没有重载的概念</p>
<pre><code>var addSomeNumber = function (num){
    return num + 100;
};

addSomeNumber = function(num){
    return num + 200;
};

var result = addSomeNumber(100);        //300
</code></pre><p>后创建的函数会覆盖先创建的函数。</p>
<p>函数声明与函数表达式：</p>
<p>解析器在想执行环境中加载数据时，对函数声明和函数表达式处理不同。解析器会率先读取函数声明，并使其在执行任何代码之前可用；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>
<pre><code>alert(sum(10, 10));
function sum(num1, num2){
    return num1 + num2;
}
</code></pre><p>可以正常运行，代码在开始执行之前，通过一个函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。</p>
<pre><code>alert(sum(10, 10));
var sum = function(num1 , num2){
    return num1 + num2;
};
</code></pre><p>以上代码在运行期间产生错误，因为函数位于一个初始化语句中，而不是一个函数中。<br>除了什么时候可以通过变脸高方文函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。</p>
<p>作为值得函数：<br>因为函数本身就是变量，所以函数可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。</p>
<pre><code>function callSomeFunction(someFunction, someArgument){
    return someFunction(someArgument);
}

function add10(num){
    return num + 10;
}

var result1 = callSomeFunction(add10, 10);
alert(result1);         //10

function getFreeting(name){
    return &quot;Hello, &quot; + name;
}

var result2 = callSomeFunction(getFreeting, &quot;HotHunter&quot;);
alert(result2);         //  &quot;Hello, HotHunter&quot;
</code></pre><p>也可以从一个函数返回另一个函数。</p>
<pre><code>function createComparisonFunction(propertyName){
    return function(object1, object2){
        var value1 = object1(propertyName);
        var value2 = object2(propertyNmae);
        if (value1 &lt; value2){
            return -1;
        }
        else if(value1 &gt; value2){
            return 1;
        }
        else {
            return 0;
        }
    };
}

var data = [{name: &quot;zachary&quot;, age: 28}, {name: &quot;Nicholas&quot;, age: 29}];

data.sort(createComparisonFunction(&quot;name&quot;));
alert(data[0].name);        //Nicholas

data.sort(createComparisonFunction(&quot;age&quot;));
alert(date[0].name);        //Zachary
</code></pre><p>函数内部属性：<br>arguments / this<br>arguments:类数组对象，包含传入函数的所有参数。包含一个callee的属性，指向拥有这个arguments对象的额函数。</p>
<pre><code>function factorial(num){
    if (num &lt;= 1){
        return 1;
    }else {
        return num * factorial(num - 1);
    }
}
</code></pre><p>定义阶乘函数一般都要用到递归算法，上面函数有名字，并且之后名字不会改变的情况下，这样定义么有问题。但是这个函数执行与函数名factoial仅仅耦合。为了消除这种紧密耦合的现象，就可以使用arguments.callee.</p>
<pre><code>function factorial(num){
    if (num &lt;= 1){
        return 1;
    } else {
        return num * arguments.callee(num - 1);
    }
}
</code></pre><p>此时当函数名重写时，都可以保证正常完成递归。</p>
<pre><code>var truefactorial = factorial;
factorial = function(){
    return 0;
}
alert(trueFactorial(5));
alert(factorial(5));
</code></pre><p>this：引用的是函数执行的环境对象，当在网页的去阿奴作用域中调用函数时，this对象阴阳的就是window。</p>
<pre><code>window.color = &quot;red&quot;;
var o = {color : &quot;blue&quot;};

function sayColor(){
    alert(this.color);
}

sayColor();     //&quot;red&quot;

o.sayColor = sayColor;
o.sayColor();       //&quot;blue&quot;
</code></pre><p>caller：保存着调用当前函数的函数的引用，在全局作用域中调用当前函数，值为null。</p>
<pre><code>function outer(){
    inner();
}
function inner(){
    alert(inner.caller);
}
outer();
</code></pre><p>以上代码将返回outer的函数源代码，为了防止耦合：</p>
<pre><code>function outer(){
    inner();
}
function inner(){
    alert(arguments.callee.caller);
}
outer();
</code></pre><p>函数的属性和方法：<br>每个函数都包含两个属性：length和prototype<br>length返回函数参数个数。</p>
<pre><code>fucntion sayName(name){
    alert(name);
}
function sum(num1, num2){
    return num1 + num2;
}
function sayHi(){
    alert(&quot;hi&quot;);
}

alert(sayName.length);          //1
alert(sum.length);              //2
alert(sayHi.length);            //0
</code></pre><p>prototype：保存它们所有实例方法的真正所在。例如toString()/valueOf()都保存在prototype名下，通过各自对象的实例访问。<br>每个函数都包含两个非继承的方法。apply()/call()。两个方法的用于都是在特定的作用与众调用函数，实际上等于设置函数体内的this的值。</p>
<p>apply()：接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组，可以是Array实例对象，也可以是arguments对象。</p>
<pre><code>function sum(num1, num2){
    return num1 + num2;
}
function callSum1(num1, num2){
    return sum.apply(this, arguments);
}
function callSum2(num1, num2){
    return sum.apply(this, [num1, num2]);
}

alert(callSum1(10, 10));            //20
alert(callSum2(10, 10));            //20
</code></pre><p>call()：与apply的区别在于接收参数不同，第一个参数this没有变化，剩下的参数都直接传递给函数。</p>
<pre><code>function sum(num1, num2){
    return num1 + num2;
}
function callSum(num1, num2){
    return sum.call(this, num1, num2);
}
alert(callSum(10, 10));             //20
</code></pre><p>apply()、call()真正作用在于扩充函数赖以运行的作用域</p>
<pre><code>window.color = &quot;red&quot;;
var o = {color : &quot;blue&quot;};

function sayColor(){
    alert(this.color);
}

sayColor();         //red

sayColor.call(this);            //red
sayColor.call(window);          //red
sayColor.call(o);               //blue
</code></pre><p>好处就是，对象不需要与方法有任何耦合关系</p>
<p>bind()：创建一个函数实例，其this值会被绑定到传给bind()函数的值。</p>
<pre><code>window.color = &quot;red&quot;;
var o = {color : &quot;blue&quot;};

function sayColor(){
    alert(this.color);
}

var objectSayColor = sayColor.bind(o);
objectSayColor();           //blue
</code></pre><p>每个函数继承的toLocaleString()/toString()/valueOf()返回函数代码</p>
<h4 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h4><p>3个特殊的Boolean/Number/String。<br>与其他引用类型类似，同事也具有哦与各自的基本类型相应的特殊行为。当读取一个基本类型值的时候，后台会创建一个对应的基本包装类型的对象。</p>
<pre><code>var s1 = &quot;some text&quot;;
var s2 = s1.substring(2);       //me text
</code></pre><p>上述实际操作：<br>创建String类型的一个实例；<br>在实例上调用指定的方法；<br>销毁这个实例。</p>
<pre><code>var s1 = new String(&quot;some text&quot;);
var s2 = s1.substring(2);
s1 = null;
</code></pre><p>引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立刻被销毁。意味着不能再运行时为基本类型值添加属性和方法。</p>
<pre><code>var s1 = &quot;some text&quot;;
s1.color = &quot;red&quot;;
alert(s1.color);        //underfined
</code></pre><p>在绝对必要的情况下这样做，因为很容易让人分不清自己是在处理基本类型还是引用类型的值。<br>注意使用new调用基本包装类型的够赞函数，与直接调用同名的转型函数时不一样的。</p>
<pre><code>var value = &quot;25&quot;;
var number = Number(value);     //转型函数
alert(typeof number);           //&quot;number&quot;

var obj = new Number(value);
alert(typeof obj);              //&quot;object&quot;
</code></pre><p>Boolean类型：</p>
<pre><code>var booleanObject = new Boolean(true);

var falseObject =  new Bollean(false);
var result = falseObject &amp;&amp; true;
alert(result);          //true

var falseValue = false;
result = falseValue &amp;&amp; true;
alert(result);          //false
</code></pre><p>基本类型和引用类型的boolean的区别：typeof操作符对基本类型返回”boolean”，对引用类型返回”object”。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false。</p>
<pre><code>alert(typeof falseObject);          //object
alert(tyeof falseValue);            //boolean
alert(falseObject instanceof Boolean);          //true
alert(falseVlue instanceof Boolean);            //false
</code></pre><p>建议永远不要使用Boolean对象。</p>
<p>Number类型：</p>
<pre><code>var numberObject = new Number(10);

var num = 10;
alert(num.toString());          //&quot;10&quot;
alert(num.toString(2));         //&quot;1010&quot;
alert(num.toString(8));         //&quot;12&quot;
alert(num.toString(10));        //&quot;10&quot;
alert(num.toString(16));        //&quot;a&quot;
</code></pre><p>toFixed()按照指定的小数位返回数值的字符串表示：</p>
<pre><code>var num = 10;
alert(num.toFixed(2));          //&quot;10.00&quot;

var num = 10.005;
alert(num.toFixed(2));          //&quot;10.01&quot;
</code></pre><p>toExponential()：返回以指数表示的数值的字符串。</p>
<pre><code>var num = 10;
alert(num.toExponential(1));            //&quot;1.0e+1&quot;
</code></pre><p>toPrecision()：可能返回fixed格式，也可能返回exponential格式。会根据要处理的数值决定是调用toFixed()还是toExponential()。</p>
<pre><code>var num = 99;
alert(num.toPrecision(1));          //&quot;1e+2&quot;
alert(num.toPrecision(2));          //&quot;99&quot;
alert(num.toPrecision(3));          //&quot;99.00&quot;
</code></pre><p>与Boolean类似，Number也可以实例化。但不推荐。</p>
<pre><code>var numberObject = new Number(10);
var numberValue = 10;

alert(typeof numberObject);         //&quot;object&quot;
alert(typeof numberValue);          //&quot;number&quot;
alert(numberObject instanceof Number);      //true
alert(numberValue instanceof Number);       //false
</code></pre><p>String类型：</p>
<pre><code>var stringObject = new String(&quot;some text&quot;);
</code></pre><p>用构造函数创建的String类型，继承的valueOf()/toString()/toLocaleString()都返回对象表示的基本字符串值。<br>String类型的每个实例都有一个length属性，返回字符串中字符数量。</p>
<pre><code>var stringValue = &quot;hello world&quot;;
alert(stringValue.length);          //&quot;11&quot;
</code></pre><p>字符方法：</p>
<p>charAt()：接收一个参数，基于0的字符位置，以单字符字符串的形式返回给定位置的那个字符。</p>
<pre><code>var stringValue = &quot;hello world&quot;;
alert(stringValue.charAt(1));       //&quot;e&quot;
</code></pre><p>charCodeAt()：接收一个参数，基于0的字符位置，返回字符编码</p>
<pre><code>var stringValue = &quot;hello world&quot;;
alert(stringValue.charCodeAt(1));       //&quot;101&quot;
</code></pre><p>另一个访问单个字符的方法：</p>
<pre><code>var stringValue = &quot;hello world&quot;;
alert(stringValue[1]);          //&quot;e&quot;
</code></pre><p>字符串方法：</p>
<p>concat()：将一个或多个字符串拼接，返回拼接得到的新字符串。而且同时可以接收任意多个字符串作为参数进行拼接。</p>
<pre><code>var stringValue = &quot;hello &quot;;
var result = stringValue.concat(&quot;world&quot;);
alert(result);      //&quot;hello world&quot;
alert(stringValue); //&quot;hello &quot;

var stringValue = &quot;hello &quot;;
var result = stringValue.concat(&quot;world&quot;, &quot;!&quot;, &quot; and&quot;, &quot; fuck me&quot;, &quot;!&quot;)
alert(result);      //&quot;hello world! and fuck me!&quot;
alert(stringValue); //&quot;hello &quot;
</code></pre><p>但是在实践中更多使用（+）操作符。简便易行。</p>
<p>slice()/substr()/substring()：截取字符串，不会修改字符串本身</p>
<pre><code>var str = &quot;hello world&quot;;
alert(str.slice(3));        //&quot;lo world&quot;
alert(str.substring(3));    //&quot;lo world&quot;
alert(str.substr(3));       //&quot;lo world&quot;
alert(str.slice(3, 7));     //&quot;lo w&quot;
alert(str.subtring(3, 7));  //&quot;lo w&quot;
alert(str.substr(3, 7));    //&quot;lo worl&quot;
</code></pre><p>参数存在负数值：</p>
<pre><code>var str = &quot;hello world&quot;;
alert(str.slice(-3));               //&quot;rld&quot;
alert(str.substring(-3));           //&apos;hello world&apos;
alert(str.substr(-3));              //&quot;rld&quot;
alert(str.slice(3, -4));            //&quot;lo w&quot;
alert(str.substring(3, -4));        //&quot;hel&quot;
alert(str.substr(3, -4));           //&quot;&quot;
</code></pre><p>字符串位置方法：</p>
<p>indexOf()/lastIndexOf()：从一个字符串中搜索给定的字符串，返回字符串的位置（没有找到返回-1）。<br>indexOf()从开头向后搜索，lastIndexOf()从末尾向前搜索。</p>
<pre><code>var stringValue = &quot;hello world&quot;;
alert(stringValue.indexOf(&quot;o&quot;));            //4
alert(stringValue.lastIndexOf(&quot;o&quot;));        //7
</code></pre><p>两个方法可接收第二个参数：表示从字符串中的哪个位置开始搜索。</p>
<pre><code>var string = &quot;hello world&quot;;
alert(string.indexOf(&quot;0&quot;, 6));          //7
alert(string.lastIndexOf(&quot;o&quot;, 6));      //4
</code></pre><p>在使用第二个参数情况下，通过循环调用这两个方法来找到所有匹配的子字符串</p>
<pre><code>var string = &quot;Lorem ipsum dolor sit amet, comsectetur adipisicing elit&quot;;
var positions = new Array();
var pos = string.indexOf(&quot;e&quot;);

while (pos &gt; -1){
    positions.push(pos);
    pos = string.indexOf(&quot;e&quot;, pos + 1);
}

alert(positions);       &quot;3,24,32,35,52&quot;
</code></pre><p>trim()：<br>创建一个字符串副本，删除前置及后缀的所有空格，然后返回结构。<br>由于返回字符串副本，所以原始字符串保持不变。<br>同时还有非标准的:trimLeft()/trimRight()</p>
<pre><code>var string = &quot;     hello world       &quot;;
var trimmedString = string.trim();
alert(string);          //&quot;     hello world       &quot;
alert(trimmedString);       //&quot;hello world&quot;
</code></pre><p>字符串大小写转换方法：<br>toLowerCase()/toLocaleLowerCase()/toUpperCase()/toLocaleUpperCase()</p>
<pre><code>var string = &quot;hello world&quot;;
alert(string.toLocaleUpperCase());          //&quot;HELLO WORLD&quot;
alert(string.toUpperCase());                //&quot;HELLO WORLD&quot;
alert(string.toLocaleLowerCase());          //&quot;hello world&quot;
alert(string.toLowerCase());                //&quot;hello world&quot;
</code></pre><p>字符串的模式匹配方法：<br>match()：在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。<br>只接受一个参数，一个正则表达式或者一个RegExp对象</p>
<pre><code>var text = &quot;cat, bat, sat, fat&quot;;
var pattern = /.at/;

//与pattern.exec(text)相同
var matches = text.match(pattern);
alert(matches.index);           //0
alert(matches[0]);              //&quot;cat&quot;
alert(pattern.lastIndex);       //0
</code></pre><p>search()：参数与mathch()的相同，由字符串或RegExp对象指定的一个正则表达式，返回字符串中第一个匹配项的索引；没有找到匹配项，返回-1。</p>
<pre><code>var text = &quot;cat, bat, sat, fat&quot;;
var pos = text.search(/at/);
alert(pos);         //1
</code></pre><p>replace()：替换字符串，两个参数：第一个可以是一个字符串或者一个RegExp对象（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。</p>
<pre><code>var text = &quot;cat, bat, sat, fat&quot;;
var result = text.replace(&quot;at&quot;, &quot;ond&quot;);
alert(result);          //&quot;cond, bat, sat, fat&quot;

result = text.replace(&quot;/at/g&quot;, &quot;ond&quot;);
alert(result);          //&quot;cond, bond, sond, fond&quot;
</code></pre><p>如果第二个参数是字符串，那么可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。</p>
<ul>
<li>$$      ＄</li>
<li>$&amp;      匹配整个模式的子字符串。=== RegExp.lastMatch</li>
<li>$’      匹配的子字符串之前的字符串。=== RegExp.leftContext</li>
<li>$`      匹配的子字符串之后的子字符串。 === RegExp.rightContext</li>
<li>$n      匹配第n个捕获组的子字符串</li>
<li>$nn     匹配第nn个捕获组的子字符串。</li>
</ul>
<p>end</p>
<pre><code>var text = &quot;cat, bat, sat, fat&quot;;
result = text.replace(/(.at)/g, &quot;word ($1)&quot;);
alert(result);      //word (cat), word (bat), word (sat), word(fat)
</code></pre><p>如果第二个参数是函数，只有一个匹配项的情况下，回向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。这个函数返回一个字符串，表示应该被替换的匹配项。</p>
<pre><code>function htmlEsape(text){
    return text.replace(/[&lt;&gt;&quot;&amp;]/g, function(match, pos, originalText){
        switch(match){
            case &quot;&lt;&quot;:
                return &quot;&amp;lt;&quot;;
            case &quot;&gt;&quot;:
                return &quot;&amp;gt;&quot;;
            case &quot;&amp;&quot;:
                return &quot;&amp;amp;&quot;;
            case &quot;\&quot;:
                return &quot;&amp;quot;&quot;;
        }
    });
}
alert(htmlEscape(&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;));
    //&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt;
</code></pre><p>以上代码实现：使用正则表达式查找字符，然后定义一个能够针对每个匹配的字符餐返回特定HTML实体的函数。</p>
<p>split()：基于制定的分隔符将一个字符串分割成多个字符串，放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（但不会讲字符串看成正则）。可以接收第二个参数：用于制定数组的大小，防止返回的数组超过既定大小。</p>
<pre><code>var colorText = &quot;red,blue,green,yellow&quot;;
var colors1 = colorText.split(&quot;,&quot;);    //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]
var colors2 = colorText.split(&quot;,&quot;, 2);  //[&quot;red&quot;, &quot;blue&quot;]
var colors3 = colorText.split(/[^\,]+/);    //[&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]
</code></pre><p>localeCompare()：比较两个字符串，返回：<br>如果字符串在字母表中排在字符串参数之前，返回一个负数。<br>如果字符串等于字符串参数，返回0；<br>如果字符串在字母表中应该排在字符串参数之后，返回一个正数</p>
<pre><code>var str = &quot;yellow&quot;;
alert(str.localeCompare(&quot;brick&quot;));          //1
alert(str.localeCompare(&quot;yellow&quot;));         //0
alert(str.localeCompare(&quot;zoo&quot;));            //-1
</code></pre><p>localeCompare()返回的数值取决于实现</p>
<pre><code>fucntion determineOrder(value){
    var result = str.localeCompare(value);
    if (result &lt; 0){
        alert(&quot;the string &apos;yellow&apos; comes before the string &apos;&quot; +　value + &quot;&apos; .&quot;);
    } else if (result &gt; 0){
        alert(&quot;the string &apos;yellow&apos; comes after the string &apos;&quot; +　value + &quot;&apos; .&quot;);
    } else {
        alert(&quot;the string &apos;yellow&apos; is equal to the string &apos;&quot; +　value + &quot;&apos; .&quot;);
    }
}
determineOrder(&quot;brick&quot;);
determineOrder(&quot;yellow&quot;);
determineOrder(&quot;zoo&quot;);
</code></pre><p>fromCharCode()：接收一个或多个字符编码，转换成一个字符串。从本质上看，这个方法与实例方法charCodeAt()执行的是相反的操作。</p>
<pre><code>alert(string.fromCharCode(104, 101, 108, 111));     //&quot;hello&quot;
</code></pre><p>HTML方法：<br>不怎么用，P130自己翻书看吧。</p>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <!-- <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span> -->
    <span class="footer__copyright">呦~❤</span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    
    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
